<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>俄罗斯方块</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			margin: 0;
			padding: 0;
			display: flex;
			flex-direction: column;
			height: 100vh;
			background-image: url('zhuye.jpg');
			background-size: cover;
			background-position: center;
			position: relative;
		}
		.navbar {
			background-color: rgba(51, 51, 51, 0.7);
			overflow: hidden;
			width: 100%;
			transition: top 0.3s ease-in-out;
			position: fixed;
			top: -60px;
			z-index: 1000;
		}
		.navbar.show { top: 0; }
		.navbar a {
			float: left;
			display: block;
			color: white;
			text-align: center;
			padding: 14px 20px;
			text-decoration: none;
		}
		.navbar a:hover { background: #ddd; color: #000; }
		.container {
			flex: 1;
			display: flex;
			gap: 20px;
			align-items: stretch;
			justify-content: center;
			padding: 100px 20px 70px;
			box-sizing: border-box;
		}
		.panel {
			background: rgba(0, 0, 0, 0.5);
			border-radius: 10px;
			color: #fff;
			padding: 16px;
			backdrop-filter: blur(2px);
		}
		.sidebar { width: 260px; display: flex; flex-direction: column; gap: 12px; }
		.title { margin: 0 0 8px; font-size: 24px; }
		.row { display: flex; gap: 10px; flex-wrap: wrap; }
		.button { cursor: pointer; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.25); color: #fff; padding: 10px 14px; border-radius: 8px; transition: .2s; }
		.button:hover { background: rgba(255,255,255,0.2); transform: translateY(-1px); }
		.kbd { display: inline-block; padding: 2px 6px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.25); border-radius: 4px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 12px; }
		canvas { background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; }
		footer { background: rgba(51,51,51,0.7); color: #fff; text-align: center; padding: 10px 0; position: fixed; bottom: 0; width: 100%; height: 50px; z-index: 1000; }
		.gameover { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; color: #fff; font-size: 36px; background: rgba(0,0,0,0.45); border-radius: 10px; }
	</style>
</head>
<body>

<div class="navbar" id="navbar">
	<a href="index.html">首页</a>
	<a href="game.html">返回游戏中心</a>
</div>

<div class="container">
	<div class="panel sidebar">
		<h2 class="title">俄罗斯方块</h2>
		<div>方向键或 <span class="kbd">A</span><span class="kbd">D</span> 左右移动，<span class="kbd">W</span>/<span class="kbd">↑</span> 旋转，<span class="kbd">S</span>/<span class="kbd">↓</span> 加速下落，<span class="kbd">Space</span> 立即下落</div>
		<div class="row">
			<button id="startBtn" class="button">开始游戏</button>
			<button id="pauseBtn" class="button">暂停</button>
			<button id="resetBtn" class="button">重开</button>
		</div>
		<div>分数：<span id="score">0</span></div>
		<div>消行：<span id="lines">0</span></div>
		<!-- 移动端控制 -->
		<div id="mobileControls" style="display:none; margin-top:8px;">
			<div style="display:grid; grid-template-columns:repeat(4,56px); grid-auto-rows:56px; gap:8px;">
				<button id="btnLeft" class="button">←</button>
				<button id="btnRight" class="button">→</button>
				<button id="btnRotate" class="button">旋转</button>
				<button id="btnSoft" class="button">下落</button>
				<button id="btnHard" class="button" style="grid-column: span 4;">硬降</button>
			</div>
		</div>
	</div>
	<div class="panel" style="position:relative;">
		<canvas id="tetris" width="300" height="600"></canvas>
		<div id="gameOverLayer" class="gameover">GAME OVER</div>
	</div>
</div>

<footer>
	<p>&copy; 2025 俄罗斯方块</p>
</footer>

<script>
	// 顶部导航显隐
	document.addEventListener('mousemove', function(e){
		var navbar = document.getElementById('navbar');
		navbar.classList.toggle('show', e.clientY < 60);
	});

	var canvas = document.getElementById('tetris');
	var ctx = canvas.getContext('2d');
	var COLS = 10, ROWS = 20, CELL = 30; // 300x600
	var board = [];
	var bag = [];
	var current = null;
	var dropCounter = 0;
	var dropInterval = 800; // 毫秒
	var lastTime = 0;
	var running = false;
	var isGameOver = false;
	var score = 0;
	var lines = 0;

	var colors = {
		'I': '#79c0ff', 'J': '#ff7b72', 'L': '#f78166', 'O': '#ffd700', 'S': '#56d364', 'T': '#d2a8ff', 'Z': '#ffa657'
	};

	function createMatrix(w, h){
		var m = [];
		for (var y = 0; y < h; y++) {
			m[y] = [];
			for (var x = 0; x < w; x++) m[y][x] = 0;
		}
		return m;
	}

	function cloneMatrix(m){ return m.map(function(r){ return r.slice(); }); }

	function shapes(type){
		if (type === 'I') return [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]];
		if (type === 'J') return [[1,0,0],[1,1,1],[0,0,0]];
		if (type === 'L') return [[0,0,1],[1,1,1],[0,0,0]];
		if (type === 'O') return [[1,1],[1,1]];
		if (type === 'S') return [[0,1,1],[1,1,0],[0,0,0]];
		if (type === 'T') return [[0,1,0],[1,1,1],[0,0,0]];
		if (type === 'Z') return [[1,1,0],[0,1,1],[0,0,0]];
		return [[1]];
	}

	function rotate(matrix){
		var N = matrix.length;
		var res = createMatrix(N, N);
		for (var y = 0; y < N; y++) {
			for (var x = 0; x < N; x++) {
				res[x][N - 1 - y] = matrix[y][x];
			}
		}
		return res;
	}

	function newPiece(){
		if (bag.length === 0) {
			bag = ['I','J','L','O','S','T','Z'];
			for (var i = bag.length - 1; i > 0; i--) {
				var j = Math.floor(Math.random() * (i + 1));
				var t = bag[i]; bag[i] = bag[j]; bag[j] = t;
			}
		}
		var type = bag.pop();
		current = {
			type: type,
			matrix: shapes(type),
			x: Math.floor(COLS / 2) - 2,
			y: 0,
			color: colors[type]
		};
		if (collide(board, current)) {
			gameOver();
		}
	}

	function collide(board, piece){
		var m = piece.matrix, o = { x: piece.x, y: piece.y };
		for (var y = 0; y < m.length; y++) {
			for (var x = 0; x < m[y].length; x++) {
				if (m[y][x]) {
					var by = y + o.y;
					var bx = x + o.x;
					if (bx < 0 || bx >= COLS || by >= ROWS) return true;
					if (by >= 0 && board[by][bx]) return true;
				}
			}
		}
		return false;
	}

	function merge(board, piece){
		var m = piece.matrix;
		for (var y = 0; y < m.length; y++) {
			for (var x = 0; x < m[y].length; x++) {
				if (m[y][x] && piece.y + y >= 0) {
					board[piece.y + y][piece.x + x] = piece.color;
				}
			}
		}
	}

	function clearLines(){
		var cleared = 0;
		for (var y = ROWS - 1; y >= 0; y--) {
			var full = true;
			for (var x = 0; x < COLS; x++) {
				if (!board[y][x]) { full = false; break; }
			}
			if (full) {
				board.splice(y, 1);
				board.unshift(new Array(COLS).fill(0));
				cleared++;
				y++; // 继续检查当前行
			}
		}
		if (cleared > 0) {
			lines += cleared;
			score += [0, 100, 300, 500, 800][cleared];
			document.getElementById('score').textContent = String(score);
			document.getElementById('lines').textContent = String(lines);
			// 提升速度
			dropInterval = Math.max(120, 800 - Math.floor(lines / 5) * 80);
		}
	}

	function drawCell(x, y, color){
		ctx.fillStyle = color;
		ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
		ctx.strokeStyle = 'rgba(255,255,255,0.08)';
		ctx.strokeRect(x * CELL + 0.5, y * CELL + 0.5, CELL - 1, CELL - 1);
	}

	function draw(){
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		// 背景网格
		ctx.fillStyle = '#30363d';
		for (var gx = 0; gx < COLS; gx++) {
			for (var gy = 0; gy < ROWS; gy++) {
				ctx.fillRect(gx * CELL + 2, gy * CELL + 2, CELL - 4, CELL - 4);
			}
		}
		// 已固定方块
		for (var y = 0; y < ROWS; y++) {
			for (var x = 0; x < COLS; x++) {
				if (board[y][x]) drawCell(x, y, board[y][x]);
			}
		}
		// 下落中的方块
		if (current) {
			for (var y2 = 0; y2 < current.matrix.length; y2++) {
				for (var x2 = 0; x2 < current.matrix[y2].length; x2++) {
					if (current.matrix[y2][x2]) drawCell(current.x + x2, current.y + y2, current.color);
				}
			}
		}
	}

	function softDrop(){
		current.y++;
		if (collide(board, current)) {
			current.y--;
			lockPiece();
		}
		DropReset();
	}

	function hardDrop(){
		while (!collide(board, current)) { current.y++; }
		current.y--;
		lockPiece();
		DropReset();
	}

	function move(dir){
		current.x += dir;
		if (collide(board, current)) current.x -= dir;
	}

	function rotateCurrent(){
		var prev = cloneMatrix(current.matrix);
		current.matrix = rotate(current.matrix);
		// 踢墙
		var kicks = [0, -1, 1, -2, 2];
		var ok = false;
		for (var i = 0; i < kicks.length; i++) {
			current.x += kicks[i];
			if (!collide(board, current)) { ok = true; break; }
			current.x -= kicks[i];
		}
		if (!ok) current.matrix = prev;
	}

	function lockPiece(){
		merge(board, current);
		clearLines();
		newPiece();
	}

	function DropReset(){
		dropCounter = 0;
	}

	function update(time){
		if (!running) return;
		var delta = time - lastTime;
		lastTime = time;
		dropCounter += delta;
		if (dropCounter > dropInterval) {
			softDrop();
		}
		draw();
		requestAnimationFrame(update);
	}

	function startGame(){
		if (running) return;
		if (isGameOver) resetGame();
		running = true;
		lastTime = performance.now();
		requestAnimationFrame(update);
	}

	function pauseGame(){ running = false; }

	function gameOver(){
		running = false;
		isGameOver = true;
		document.getElementById('gameOverLayer').style.display = 'flex';
	}

	function resetGame(){
		running = false;
		isGameOver = false;
		board = createMatrix(COLS, ROWS);
		bag = [];
		current = null;
		dropCounter = 0;
		dropInterval = 800;
		score = 0; lines = 0;
		document.getElementById('score').textContent = '0';
		document.getElementById('lines').textContent = '0';
		document.getElementById('gameOverLayer').style.display = 'none';
		newPiece();
		draw();
	}

	// 事件
	document.addEventListener('keydown', function(e){
		if (!current) return;
		if (!running) return;
		if (e.code === 'ArrowLeft' || e.code === 'KeyA') move(-1);
		else if (e.code === 'ArrowRight' || e.code === 'KeyD') move(1);
		else if (e.code === 'ArrowUp' || e.code === 'KeyW') rotateCurrent();
		else if (e.code === 'ArrowDown' || e.code === 'KeyS') softDrop();
		else if (e.code === 'Space') hardDrop();
	});

	var startBtn = document.getElementById('startBtn');
	var pauseBtn = document.getElementById('pauseBtn');
	var resetBtn = document.getElementById('resetBtn');
	startBtn.addEventListener('click', startGame);
	pauseBtn.addEventListener('click', pauseGame);
	resetBtn.addEventListener('click', resetGame);

	// 初始化
	resetGame();

	// 移动端适配：显示按钮、缩放画布
	(function(){
		var mobileControls = document.getElementById('mobileControls');
		function resize(){
			if (window.innerWidth <= 900) {
				mobileControls.style.display = 'block';
				var maxW = Math.min(window.innerWidth - 24, 300);
				var r = maxW / canvas.width;
				canvas.style.width = maxW + 'px';
				canvas.style.height = (canvas.height * r) + 'px';
			} else {
				mobileControls.style.display = 'none';
				canvas.style.width = '';
				canvas.style.height = '';
			}
		}
		window.addEventListener('resize', resize);
		resize();
		function bind(id, fn){
			var el = document.getElementById(id);
			if (!el) return;
			el.addEventListener('click', fn);
			el.addEventListener('touchstart', function(e){ fn(); e.preventDefault(); }, { passive:false });
		}
		bind('btnLeft', function(){ if (running) move(-1); });
		bind('btnRight', function(){ if (running) move(1); });
		bind('btnRotate', function(){ if (running) rotateCurrent(); });
		bind('btnSoft', function(){ if (running) softDrop(); });
		bind('btnHard', function(){ if (running) hardDrop(); });
	})();

</script>

</body>
</html>


